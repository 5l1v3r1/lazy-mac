--import Lattice

module Sequential.Erasure where

open import Types
import Lattice
open Lattice.Lattice ­ЮЊЏ renaming (_РЅЪ_ to _РЅЪр┤И_)

open import Sequential.Calculus
open import Sequential.Semantics
open import Data.Sum

-- A view over sensitive (secret) computation types.
-- lр┤г is the attacker's security level
data Secret (lр┤г : Label) : Ty -> Set where
  Macр┤┤ : Рѕђ {h ¤ё} -> (hРІцlр┤г : h РІц lр┤г) -> Secret lр┤г (Mac h ¤ё)
  -- Resр┤┤ is not here because it is always erased homomorphically
  -- like Public types, except for the constructor Res.


-- A view over insensitive (public) types.
-- lр┤г is the attacker's security level
data Public (lр┤г : Label) : Ty -> Set where
  Macр┤И : Рѕђ {¤ё l} -> (lРіЉlр┤г : l РіЉ lр┤г) -> Public lр┤г (Mac l ¤ё)
  Res : Рѕђ {¤ё l} -> (lРіЉ?lр┤г : Dec (l РіЉ lр┤г)) -> Public lр┤г (Res l ¤ё)
  №╝ѕ№╝Ѕ : Public lр┤г №╝ѕ№╝Ѕ
  Bool : Public lр┤г Bool
  Id : Рѕђ {¤ё} ->  Public lр┤г (Id ¤ё)
  Fun : Рѕђ {╬▒ ╬▓} -> Public lр┤г (╬▒ => ╬▓)

-- Secret and insensitive are mutually exclusive
secretNotPublic : Рѕђ {¤ё lр┤г} -> Secret lр┤г ¤ё -> Public lр┤г ¤ё -> РіЦ
secretNotPublic (Macр┤┤ ┬гp) (Macр┤И p) = ┬гp p

Level : Label -> Ty -> Set
Level lр┤г ¤ё = (Secret lр┤г ¤ё) Ріј (Public lр┤г ¤ё)

isSecret? : (lр┤г : Label) (¤ё : Ty) -> Level lр┤г ¤ё
isSecret? lр┤г №╝ѕ№╝Ѕ = injРѓѓ №╝ѕ№╝Ѕ
isSecret? lр┤г Bool = injРѓѓ Bool
isSecret? lр┤г (¤ё => ¤ёРѓЂ) = injРѓѓ Fun
isSecret? lр┤г (Mac l ¤ё) with l РіЉ? lр┤г
isSecret? lр┤г (Mac l ¤ё) | yes p = injРѓѓ (Macр┤И p)
isSecret? lр┤г (Mac l ¤ё) | no ┬гp = injРѓЂ (Macр┤┤ ┬гp)
isSecret? lр┤г (Res l ¤ё) = injРѓѓ (Res (l РіЉ? lр┤г))
isSecret? lр┤г (Id ¤ё) = injРѓѓ Id

-- Erasure Function (entry-point)
╬хрхђ : Рѕђ {¤ё n} {¤ђ : Context n} -> (lр┤г : Label) -> Term ¤ђ ¤ё -> Term ¤ђ ¤ё
╬хр┤┤ : Рѕђ {lр┤г n ¤ё} {¤ђ : Context n} -> Secret lр┤г ¤ё -> Term ¤ђ ¤ё -> Term ¤ђ ¤ё
╬хр┤И : Рѕђ {lр┤г n ¤ё} {¤ђ : Context n} -> Public lр┤г ¤ё -> Term ¤ђ ¤ё -> Term ¤ђ ¤ё


╬хр┤┤ (Macр┤┤ hРІцlр┤г) t = РѕЎ

╬хр┤И p №╝ѕ№╝Ѕ = №╝ѕ№╝Ѕ
╬хр┤И p True = True
╬хр┤И p False = False
╬хр┤И {l} p (Id t) = Id (╬хрхђ l t)
╬хр┤И {l} p (unId t) = unId (╬хр┤И {l} Id t)
╬хр┤И p (Var xРѕѕ¤ђ) = Var xРѕѕ¤ђ
╬хр┤И {l} p (Abs x t) = Abs x (╬хрхђ l t)
╬хр┤И {l} p (App t tРѓЂ) = App (╬хр┤И {l} Fun t) (╬хрхђ l tРѓЂ)
╬хр┤И {l} p (If t Then tРѓЂ Else tРѓѓ) = If (╬хр┤И {l} Bool t) Then ╬хр┤И p tРѓЂ Else ╬хр┤И p tРѓѓ
╬хр┤И {lр┤г} p (Return l t) = Return l (╬хрхђ lр┤г t)
╬хр┤И {lр┤г} (Macр┤И lРіЉlр┤г) (t >>= tРѓЂ) = (╬хр┤И (Macр┤И lРіЉlр┤г) t) >>= ╬хр┤И {lр┤г} Fun tРѓЂ
╬хр┤И {lр┤г} p (Mac l t) = Mac l (╬хрхђ lр┤г t)
╬хр┤И {lр┤г} (Res (yes p)) (Res l t) = Res l (╬хрхђ lр┤г t)
╬хр┤И (Res (no ┬гp)) (Res l t) = Res l РѕЎ
╬хр┤И {lр┤г} p (label {l} {h} lРіЉh t) with h РіЉ? lр┤г
╬хр┤И {lр┤г} pРѓЂ (label lРіЉh t) | yes p = label lРіЉh (╬хрхђ lр┤г t)
╬хр┤И {lр┤г} p (label lРіЉh t) | no ┬гp = labelРѕЎ lРіЉh (╬хрхђ lр┤г t)
╬хр┤И {lр┤г} p (labelРѕЎ lРіЉh t) = labelРѕЎ lРіЉh (╬хрхђ lр┤г t)
╬хр┤И {lр┤г} (Macр┤И lРіЉlр┤г) (unlabel {l} {h} lРіЉh t) = unlabel lРіЉh (╬хр┤И (Res (yes (trans-РіЉ lРіЉh lРіЉlр┤г))) t)
╬хр┤И {lр┤г} p (fork lРіЉh t) = fork lРіЉh (╬хрхђ lр┤г t)
╬хр┤И p (deepDup x) = deepDup x
╬хр┤И p РѕЎ = РѕЎ

╬хрхЌ : Рѕђ {lр┤г ¤ё n} {¤ђ : Context n} -> (Secret lр┤г ¤ё) Ріј (Public lр┤г ¤ё) -> Term ¤ђ ¤ё -> Term ¤ђ ¤ё
╬хрхЌ (injРѓЂ x) t = ╬хр┤┤ x t
╬хрхЌ (injРѓѓ y) t = ╬хр┤И y t

╬хрхђ {¤ё} lр┤г t = ╬хрхЌ (isSecret? lр┤г ¤ё) t

--------------------------------------------------------------------------------

open import Data.Product as P
open import Data.Maybe as M
open import Function

-- Point-wise erasure of a RawEnv
╬хр┤┐ : Рѕђ {n} {¤ђ : Context n} -> Label -> RawEnv ¤ђ -> RawEnv ¤ђ
╬хр┤┐ lр┤г M n = P.map id (M.map (╬хрхђ lр┤г)) (M n)

-- Constant mapping to РѕЎ (it can be modified and this is a problem)
-- We need the old environment for the type
РѕЎр┤┐ : Рѕђ {n} {¤ђ : Context n} -> RawEnv ¤ђ -> RawEnv ¤ђ
РѕЎр┤┐ M n = projРѓЂ (M n) , just РѕЎ

╬хр┤▒ : Рѕђ {l lр┤г n} {¤ђ : Context n} -> Dec (l РіЉ lр┤г) ->  Env l ¤ђ -> Env l ¤ђ
╬хр┤▒ {_} {lр┤г} (yes p) (RE x) = RE (╬хр┤┐ lр┤г x)
╬хр┤▒ (no ┬гp) (RE x) = RE (РѕЎр┤┐ x)  -- Here I should have a different Env that is not updateable

-- Heap Erasure Function
╬х╩░ : (lр┤г : Label) -> Heap -> Heap
╬х╩░ lр┤г ╬Њ l with ╬Њ l
╬х╩░ lр┤г ╬Њ l | n , ¤ђ , ╬ћ = n , ¤ђ , ╬хр┤▒ (l РіЉ? lр┤г) ╬ћ

--------------------------------------------------------------------------------

╬хрХю : Рѕђ {¤ёРѓЂ ¤ёРѓѓ} -> (lр┤г : Label) -> Cont ¤ёРѓЂ ¤ёРѓѓ -> Cont ¤ёРѓЂ ¤ёРѓѓ
╬хрХю lр┤г (Var xРѕѕ¤ђ) = Var xРѕѕ¤ђ
╬хрХю lр┤г (# xРѕѕ¤ђ) = # xРѕѕ¤ђ
╬хрХю lр┤г (Then tРѓЂ Else tРѓѓ) = Then (╬хрхђ lр┤г tРѓЂ) Else ╬хрхђ lр┤г tРѓѓ
╬хрХю lр┤г (Bind t) = Bind (╬хрхђ lр┤г t)
╬хрХю lр┤г (unlabel p) = unlabel p
╬хрХю lр┤г unId = unId

╬х╦б : Рѕђ {¤ёРѓЂ ¤ёРѓѓ l} -> (lр┤г : Label) -> Stack l ¤ёРѓЂ ¤ёРѓѓ -> Stack l ¤ёРѓЂ ¤ёРѓѓ

╬хрхЈ : Рѕђ {¤ёРѓЂ ¤ёРѓѓ l lр┤г} -> (Secret lр┤г ¤ёРѓЂ) Ріј (Public lр┤г ¤ёРѓЂ) -> Stack l ¤ёРѓЂ ¤ёРѓѓ -> Stack l ¤ёРѓЂ ¤ёРѓѓ
╬хрхЈ (injРѓЂ x) S = РѕЎ
╬хрхЈ (injРѓѓ y) [] = []
╬хрхЈ {lр┤г = lр┤г} (injРѓѓ y) (x Рѕи S) = ╬хрХю lр┤г x Рѕи ╬хрхЈ (isSecret? lр┤г _) S
╬хрхЈ (injРѓѓ y) РѕЎ = РѕЎ

╬х╦б {¤ёРѓЂ} lр┤г S = ╬хрхЈ (isSecret? lр┤г ¤ёРѓЂ) S


--------------------------------------------------------------------------------

╬х' : Рѕђ {lр┤г l ¤ё ¤ё' n} {¤ђ : Context n} -> Level lр┤г ¤ё -> Term ¤ђ ¤ё -> Stack l ¤ё ¤ё' -> (Term ¤ђ ¤ё ├Ќ Stack l ¤ё ¤ё')
╬х' (injРѓЂ x) t S = РѕЎ , РѕЎ
╬х' (injРѓѓ y) t [] = (╬хр┤И y t) , []
╬х' {lр┤г} (injРѓѓ y) t (_Рѕи_ {¤ёРѓѓ = ¤ёРѓѓ} c S) with isSecret? lр┤г ¤ёРѓѓ
╬х' (injРѓѓ y) t (c Рѕи S) | injРѓЂ x = РѕЎ , РѕЎ
╬х' {lр┤г} (injРѓѓ yРѓЂ) t (c Рѕи S) | injРѓѓ y = (╬хр┤И yРѓЂ t) , ╬хрХю lр┤г c Рѕи (╬х╦б lр┤г S)
╬х' (injРѓѓ y) t РѕЎ = РѕЎ , РѕЎ

╬х : Рѕђ {l ¤ё} (lр┤г : Label) -> State l ¤ё -> State l ¤ё
╬х lр┤г РЪе ╬Њ , t , S РЪЕ with ╬х' (isSecret? lр┤г _) t S
╬х lр┤г РЪе ╬Њ , t , S РЪЕ | tрхЅ , SрхЅ = РЪе ╬х╩░ lр┤г ╬Њ , tрхЅ , SрхЅ РЪЕ

--------------------------------------------------------------------------------

open import Relation.Binary.PropositionalEquality

{-

Homomorphic erasure function for MAC H and stack does works for BindРѓЂ but not for BindРѓѓ

BindРѓЂ:
(╬Њ , tРѓЂ >>= tРѓѓ , S) Рєњ (╬Њ , tРѓЂ , >>= tРѓѓ : S)

(╬х(╬Њ) , ╬х(tРѓЂ) >>= ╬х(tРѓѓ) , ╬х(S)) Рєњ (╬х(╬Њ) , ╬х(tРѓЂ) , >>= ╬х(tРѓѓ) : ╬х(S))

BindРѓѓ:
(╬Њ , Mac tРѓЂ , >>= tРѓѓ : S) Рєњ (╬Њ , tРѓѓ tРѓЂ , S)

(╬х(╬Њ) , Mac РѕЎ , >>= ╬х(tРѓѓ) : ╬х(S)) РєЏ (╬х(╬Њ) , ╬х(tРѓѓ) ╬х(tРѓЂ) , ╬х(S))  -- tРѓЂ РЅа РѕЎ

-}
--╬хРѕЎРЅАРѕЎ : Рѕђ {¤ё

╬х-sim' : Рѕђ {lр┤г l ¤ёРѓЂ ¤ёРѓѓ ¤ёРѓЃ nРѓЂ nРѓѓ ╬Њ ╬Њ'} {¤ђРѓЂ : Context nРѓЂ} {¤ђРѓѓ : Context nРѓѓ} {tРѓЂ : Term ¤ђРѓЂ ¤ёРѓЂ} {tРѓѓ : Term ¤ђРѓѓ ¤ёРѓѓ} {SРѓЂ : Stack l ¤ёРѓЂ ¤ёРѓЃ} {SРѓѓ : Stack l ¤ёРѓѓ ¤ёРѓЃ} ->
         (x : Level lр┤г ¤ёРѓЂ) (y : Level lр┤г ¤ёРѓѓ) ->
         РЪе ╬Њ , tРѓЂ , SРѓЂ РЪЕ РЄЮ РЪе ╬Њ' , tРѓѓ , SРѓѓ РЪЕ ->
           let tрхЅ , SрхЅ = ╬х' x tРѓЂ SРѓЂ
               tрхЅ'  , SрхЅ' = ╬х' y tРѓѓ SРѓѓ in РЪе ╬х╩░ lр┤г ╬Њ , tрхЅ , SрхЅ РЪЕ РЄЮ РЪе (╬х╩░ lр┤г ╬Њ') , tрхЅ' , SрхЅ' РЪЕ
╬х-sim' (injРѓЂ x) y (AppРѓЂ ╬ћРѕѕ╬Њ) = {!!}
╬х-sim' (injРѓЂ x) y (AppРѓѓ yРѕѕ¤ђ xРѕѕ¤ђ) = {!!}
╬х-sim' (injРѓЂ x) y (VarРѓЂ ╬ћРѕѕ╬Њ xРѕѕ¤ђ tРѕѕ╬ћ ┬гval) = {!!}
╬х-sim' (injРѓЂ x) y (VarРѓЂ' ╬ћРѕѕ╬Њ xРѕѕ¤ђ vРѕѕ╬ћ val) = {!!}
╬х-sim' (injРѓЂ x) y (VarРѓѓ ╬ћРѕѕ╬Њ xРѕѕ¤ђ val) = {!!}
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) If = Hole
╬х-sim' {lр┤г} (injРѓЂ (Macр┤┤ {h = h} hРІцlр┤г)) (injРѓѓ Bool) If with h РіЉ? lр┤г
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ Bool) If | yes p = РіЦ-elim (hРІцlр┤г p)
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ Bool) If | no ┬гp = Hole
╬х-sim' (injРѓЂ ()) y IfTrue
╬х-sim' (injРѓЂ ()) y IfFalse
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) Return = Hole
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Macр┤И lРіЉlр┤г)) Return = РіЦ-elim (hРІцlр┤г lРіЉlр┤г)
╬х-sim' (injРѓЂ xРѓЂ) (injРѓЂ x) BindРѓЂ = Hole
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Macр┤И lРіЉlр┤г)) BindРѓЂ = РіЦ-elim (hРІцlр┤г lРіЉlр┤г)
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) BindРѓѓ = Hole
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Macр┤И lРіЉlр┤г)) BindРѓѓ = РіЦ-elim (hРІцlр┤г lРіЉlр┤г)
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) (Label' p) = Hole
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Macр┤И lРіЉlр┤г)) (Label' p) = РіЦ-elim (hРІцlр┤г lРіЉlр┤г)
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) (UnlabelРѓЂ p) = Hole
╬х-sim' {lр┤г} {l} (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Res lРіЉ?lр┤г)) (UnlabelРѓЂ p) with l РіЉ? lр┤г
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Res lРіЉ?lр┤г)) (UnlabelРѓЂ pРѓЂ) | yes p = РіЦ-elim (hРІцlр┤г p)
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Res lРіЉ?lр┤г)) (UnlabelРѓЂ p) | no ┬гp = Hole
╬х-sim' (injРѓЂ xРѓЂ) (injРѓЂ x) (UnlabelРѓѓ p) = Hole
╬х-sim' (injРѓЂ ()) (injРѓѓ (Macр┤И lРіЉlр┤г)) (UnlabelРѓѓ p)
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) UnIdРѓЂ = Hole
╬х-sim' {lр┤г} (injРѓЂ (Macр┤┤ {h = h} hРІцlр┤г)) (injРѓѓ Id) UnIdРѓЂ with h РіЉ? lр┤г
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ Id) UnIdРѓЂ | yes p = РіЦ-elim (hРІцlр┤г p)
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ Id) UnIdРѓЂ | no ┬гp = Hole
╬х-sim' (injРѓЂ ()) y UnIdРѓѓ
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) (Fork p) = Hole
╬х-sim' (injРѓЂ (Macр┤┤ hРІцlр┤г)) (injРѓѓ (Macр┤И lРіЉlр┤г)) (Fork p) = РіЦ-elim (hРІцlр┤г lРіЉlр┤г)
╬х-sim' (injРѓЂ x) (injРѓЂ xРѓЂ) Hole = Hole
╬х-sim' (injРѓЂ x) (injРѓѓ y) Hole = Hole
╬х-sim' (injРѓѓ y) yРѓЂ (AppРѓЂ ╬ћРѕѕ╬Њ) = ?
╬х-sim' (injРѓѓ y) yРѓЂ (AppРѓѓ yРѕѕ¤ђ xРѕѕ¤ђ) = ?
╬х-sim' (injРѓѓ y) yРѓЂ (VarРѓЂ ╬ћРѕѕ╬Њ xРѕѕ¤ђ tРѕѕ╬ћ ┬гval) = ?
╬х-sim' (injРѓѓ y) yРѓЂ (VarРѓЂ' ╬ћРѕѕ╬Њ xРѕѕ¤ђ vРѕѕ╬ћ val) = ?
╬х-sim' (injРѓѓ y) yРѓЂ (VarРѓѓ ╬ћРѕѕ╬Њ xРѕѕ¤ђ val) = ?
╬х-sim' (injРѓѓ y) yРѓЂ If = ?
╬х-sim' (injРѓѓ y) yРѓЂ IfTrue = ?
╬х-sim' (injРѓѓ y) yРѓЂ IfFalse = ?
╬х-sim' (injРѓѓ y) yРѓЂ Return = ?
╬х-sim' (injРѓѓ y) yРѓЂ BindРѓЂ = ?
╬х-sim' (injРѓѓ y) yРѓЂ BindРѓѓ = ?
╬х-sim' (injРѓѓ y) yРѓЂ (Label' p) = ?
╬х-sim' (injРѓѓ y) yРѓЂ (UnlabelРѓЂ p) = ?
╬х-sim' (injРѓѓ y) yРѓЂ (UnlabelРѓѓ p) = ?
╬х-sim' (injРѓѓ y) yРѓЂ UnIdРѓЂ = ?
╬х-sim' (injРѓѓ y) yРѓЂ UnIdРѓѓ = ?
╬х-sim' (injРѓѓ y) yРѓЂ (Fork p) = ?
╬х-sim' (injРѓѓ y) yРѓЂ Hole = ?

-- Simulation Property
╬х-sim : Рѕђ {lр┤г l ¤ё} {sРѓЂ sРѓѓ : State l ¤ё} -> sРѓЂ РЄЮ sРѓѓ -> ╬х lр┤г sРѓЂ РЄЮ ╬х lр┤г sРѓѓ
╬х-sim step = {!!}

-- -- If l is H then ok, but in general l could be L. In this case Hole does not apply because ╬Њ changes.
-- -- I think that ╬Њ = РѕЎ could work
-- ╬х-sim (injРѓЂ (Macр┤┤ hРІцlр┤г)) (AppРѓЂ ╬ћРѕѕ╬Њ) = {!!}
-- ╬х-sim (injРѓЂ x) (AppРѓѓ yРѕѕ¤ђ xРѕѕ¤ђ) = Hole
-- ╬х-sim (injРѓЂ x) (VarРѓЂ ╬ћРѕѕ╬Њ xРѕѕ¤ђ tРѕѕ╬ћ ┬гval) = {!!} -- Must show that lр┤г РІц l'
-- ╬х-sim (injРѓЂ x) (VarРѓЂ' ╬ћРѕѕ╬Њ xРѕѕ¤ђ vРѕѕ╬ћ val) = Hole
-- ╬х-sim (injРѓЂ x) (VarРѓѓ ╬ћРѕѕ╬Њ xРѕѕ¤ђ val) = {!!} -- Must show that lр┤г РІц l'
-- ╬х-sim (injРѓЂ x) If = Hole
-- ╬х-sim (injРѓЂ x) IfTrue = Hole
-- ╬х-sim (injРѓЂ x) IfFalse = Hole
-- ╬х-sim (injРѓЂ x) Return = Hole
-- ╬х-sim (injРѓЂ x) BindРѓЂ = Hole
-- ╬х-sim (injРѓЂ x) BindРѓѓ = Hole
-- ╬х-sim (injРѓЂ x) (Label' p) = Hole
-- ╬х-sim (injРѓЂ x) (UnlabelРѓЂ p) = Hole
-- ╬х-sim (injРѓЂ x) (UnlabelРѓѓ p) = Hole
-- ╬х-sim (injРѓЂ x) UnIdРѓЂ = Hole
-- ╬х-sim (injРѓЂ x) UnIdРѓѓ = Hole
-- ╬х-sim (injРѓЂ x) (Fork p) = Hole
-- ╬х-sim (injРѓЂ x) Hole = Hole
-- ╬х-sim (injРѓѓ y) (AppРѓЂ ╬ћРѕѕ╬Њ) = {!!}
-- ╬х-sim (injРѓѓ y) (AppРѓѓ yРѕѕ¤ђ xРѕѕ¤ђ) = {!!}
-- ╬х-sim (injРѓѓ y) (VarРѓЂ ╬ћРѕѕ╬Њ xРѕѕ¤ђ tРѕѕ╬ћ ┬гval) = {!!}
-- ╬х-sim (injРѓѓ y) (VarРѓЂ' ╬ћРѕѕ╬Њ xРѕѕ¤ђ vРѕѕ╬ћ val) = {!!}
-- ╬х-sim (injРѓѓ y) (VarРѓѓ ╬ћРѕѕ╬Њ xРѕѕ¤ђ val) = {!!}
-- ╬х-sim (injРѓѓ y) If = {!y!}  -- :|
-- ╬х-sim (injРѓѓ y) IfTrue = IfTrue
-- ╬х-sim (injРѓѓ y) IfFalse = IfFalse
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) Return with l РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) Return | yes p = Return
-- ╬х-sim (injРѓѓ y) Return | no ┬гp = Hole
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) BindРѓЂ with l РіЉ? lр┤г
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) BindРѓЂ | yes p with l РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) BindРѓЂ | yes pРѓЂ | yes p = {!BindРѓЂ!} -- Lemma, proof irrelevance for РіЉ
-- ╬х-sim (injРѓѓ y) BindРѓЂ | yes p | no ┬гp = РіЦ-elim (┬гp p)
-- ╬х-sim (injРѓѓ y) BindРѓЂ | no ┬гp = Hole
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) BindРѓѓ with l РіЉ? lр┤г
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) BindРѓѓ | yes p with l РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) BindРѓѓ | yes pРѓЂ | yes p = {!BindРѓѓ!} -- Lemma, proof irrelevance for РіЉ
-- ╬х-sim (injРѓѓ y) BindРѓѓ | yes p | no ┬гp = РіЦ-elim (┬гp p)
-- ╬х-sim (injРѓѓ y) BindРѓѓ | no ┬гp = Hole
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) (Label' p) with l РіЉ? lр┤г
-- ╬х-sim {lр┤г = lр┤г} (injРѓѓ y) (Label' {h = h} pРѓЂ) | yes p with h РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) (Label' pРѓѓ) | yes pРѓЂ | yes p = Label' pРѓѓ
-- ╬х-sim (injРѓѓ y) (Label' pРѓЂ) | yes p | no ┬гp = {!!} -- Add LabelРѕЎ step: labelРѕЎ t РЄЮ return (Res РѕЎ)
-- ╬х-sim (injРѓѓ y) (Label' p) | no ┬гp = Hole
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) (UnlabelРѓЂ p) with l РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) (UnlabelРѓЂ pРѓЂ) | yes p = {!UnlabelРѓЂ ?!} -- Lemma
-- ╬х-sim {lр┤г = lр┤г} (injРѓѓ y) (UnlabelРѓЂ {l' = l'} p) | no ┬гp = {!!} -- :|
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) (UnlabelРѓѓ p) with l РіЉ? lр┤г
-- ╬х-sim {lр┤г = lр┤г} (injРѓѓ y) (UnlabelРѓѓ {l' = l'} pРѓЂ) | yes p with l' РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) (UnlabelРѓѓ pРѓѓ) | yes pРѓЂ | yes p = {!!} -- :|
-- ╬х-sim (injРѓѓ y) (UnlabelРѓѓ pРѓЂ) | yes p | no ┬гp = РіЦ-elim (┬гp (trans-РіЉ pРѓЂ p))
-- ╬х-sim {lр┤г = lр┤г} (injРѓѓ y) (UnlabelРѓѓ {l' = l'} p) | no ┬гp with l' РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) (UnlabelРѓѓ pРѓЂ) | no ┬гp | yes p = {!!} -- UnlabelРѕЎ
-- ╬х-sim (injРѓѓ y) (UnlabelРѓѓ p) | no ┬гpРѓЂ | no ┬гp = {!UnlabelРѓѓ ?!} -- UnlabelРѕЎ : (Res t , UnlabelРѕЎ Рѕи S) Рєњ  (РѕЎ , РѕЎ)
-- ╬х-sim (injРѓѓ y) UnIdРѓЂ = {!UnIdРѓЂ!} -- :|
-- ╬х-sim (injРѓѓ y) UnIdРѓѓ = UnIdРѓѓ
-- ╬х-sim {lр┤г = lр┤г} {l} (injРѓѓ y) (Fork p) with l РіЉ? lр┤г
-- ╬х-sim (injРѓѓ y) (Fork pРѓЂ) | yes p = Fork pРѓЂ
-- ╬х-sim (injРѓѓ y) (Fork p) | no ┬гp = Hole
-- ╬х-sim {lр┤г = lр┤г} (injРѓѓ y) (Hole {¤ёРѓЂ = ¤ёРѓЂ} {¤ёРѓѓ} {¤ђРѓЂ = ¤ђРѓЂ} {¤ђРѓѓ}) with isSecret? lр┤г ¤ёРѓЂ | isSecret? lр┤г ¤ёРѓѓ
-- ╬х-sim (injРѓѓ y) Hole | injРѓЂ (Macр┤┤ hРІцlр┤г) | injРѓЂ (Macр┤┤ hРІцlр┤гРѓЂ) = Hole
-- ╬х-sim (injРѓѓ yРѓЂ) Hole | injРѓЂ (Macр┤┤ hРІцlр┤г) | injРѓѓ y = Hole
-- ╬х-sim (injРѓѓ yРѓЂ) Hole | injРѓѓ y | injРѓЂ (Macр┤┤ hРІцlр┤г) = Hole
-- ╬х-sim (injРѓѓ yРѓѓ) Hole | injРѓѓ y | injРѓѓ yРѓЂ = Hole
